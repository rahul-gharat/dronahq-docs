"use strict";(self.webpackChunkdronahq_docs=self.webpackChunkdronahq_docs||[]).push([[5358],{603905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>h});var n=r(667294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var c=n.createContext({}),l=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},p=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},f=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=l(r),f=a,h=u["".concat(c,".").concat(f)]||u[f]||d[f]||o;return r?n.createElement(h,i(i({ref:t},p),{},{components:r})):n.createElement(h,i({ref:t},p))}));function h(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=f;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[u]="string"==typeof e?e:a,i[1]=s;for(var l=2;l<o;l++)i[l]=r[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}f.displayName="MDXCreateElement"},184425:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>p,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>l,toc:()=>u});r(667294);var n=r(603905);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):function(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))})),e}function i(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}const s={sidebar_position:74,title:"Best practices for high performance apps"},c="Best practices for high performance apps",l={unversionedId:"best_practices_for_high_performance_apps",id:"best_practices_for_high_performance_apps",title:"Best practices for high performance apps",description:"As your DronaHQ apps evolve, incorporating intricate functionalities and interacting with a growing array of data sources, it becomes crucial to closely monitor their performance and implement optimizations as necessary. Performance-related challenges can arise from various factors, often complicated further when external elements come into play.",source:"@site/docs/best_practices_for_high_performance_apps.md",sourceDirName:".",slug:"/best_practices_for_high_performance_apps",permalink:"/best_practices_for_high_performance_apps",draft:!1,tags:[],version:"current",lastUpdatedAt:1688732535,formattedLastUpdatedAt:"Jul 7, 2023",sidebarPosition:74,frontMatter:{sidebar_position:74,title:"Best practices for high performance apps"},sidebar:"docSidebar",previous:{title:"Import and export apps",permalink:"/import_and_export_apps"},next:{title:"Org and User management",permalink:"/_heading_org_user_management"}},p={},u=[{value:"Check external factors",id:"check-external-factors",level:3},{value:"Avoid duplicate API or Database calls",id:"avoid-duplicate-api-or-database-calls",level:3},{value:"Minimize dependent references",id:"minimize-dependent-references",level:3},{value:"Build multi screen apps",id:"build-multi-screen-apps",level:3},{value:"Use paging in large datasets",id:"use-paging-in-large-datasets",level:3},{value:"Use control caching",id:"use-control-caching",level:3},{value:"Restrict the number of queries on page load",id:"restrict-the-number-of-queries-on-page-load",level:3},{value:"Break the app into multiple apps",id:"break-the-app-into-multiple-apps",level:3},{value:"Check query performance",id:"check-query-performance",level:3},{value:"Deploy DronaHQ on-premise",id:"deploy-dronahq-on-premise",level:3}],d={toc:u},f="wrapper";function h(e){var{components:t}=e,r=i(e,["components"]);return(0,n.kt)(f,o(function(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{},n=Object.keys(r);"function"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(r).filter((function(e){return Object.getOwnPropertyDescriptor(r,e).enumerable})))),n.forEach((function(t){a(e,t,r[t])}))}return e}({},d,r),{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"best-practices-for-high-performance-apps"},"Best practices for high performance apps"),(0,n.kt)("p",null,"As your DronaHQ apps evolve, incorporating intricate functionalities and interacting with a growing array of data sources, it becomes crucial to closely monitor their performance and implement optimizations as necessary. Performance-related challenges can arise from various factors, often complicated further when external elements come into play."),(0,n.kt)("p",null,"To ensure optimal efficiency and preempt performance degradation, we recommend following these technical best practices:"),(0,n.kt)("h3",{id:"check-external-factors"},"Check external factors"),(0,n.kt)("p",null,"Applications consist of a diverse array of interconnected components that facilitate data retrieval from third-party services. Do adopt a systematic approach by initially investigating and eliminating any potential user-related factors. This involves considering scenarios such as internet connectivity issues, outdated web browsers, or suboptimal Wi-Fi coverage. Once user-related factors are ruled out, the focus can then shift towards examining the possibility of service disruptions concerning connected APIs or databases. By following this methodical approach, you can effectively diagnose and address issues, ensuring seamless app functionality and an enhanced user experience."),(0,n.kt)("h3",{id:"avoid-duplicate-api-or-database-calls"},"Avoid duplicate API or Database calls"),(0,n.kt)("p",null,"Avoid unnecessary Connector Calls. Make sure that your App logic is optimized to avoid unnecessary calls to an app. For example in multiform scenarios when using data from APIs, you may need different types of data from the same source but using some transformation or filter. At times certain filters may not be supported by an API. So to avoid multiple API calls, it is better to use a ",(0,n.kt)("inlineCode",{parentName:"p"},"Data Query")," and then use Custom JS to have different set of data from the same source, filtered differently. "),(0,n.kt)("h3",{id:"minimize-dependent-references"},"Minimize dependent references"),(0,n.kt)("p",null,"When building apps, it is common to have a deep and complex chain of references to components and controls. You can toggle off the ",(0,n.kt)("inlineCode",{parentName:"p"},"Trigger forward dependencies")," in properties of specific controls which you might have referenced at a lot of places. This will minimize the data evaluation across these control when the referenced control value changes."),(0,n.kt)("h3",{id:"build-multi-screen-apps"},"Build multi screen apps"),(0,n.kt)("p",null,"DronaHQ has an effective multi screen experience which is not only great for the user user experience but it also helps you divide the connector or data calls across different screens. The way DronaHQ is architected is that only when a particular control gets initialized on a particular screen does the referenced ",(0,n.kt)("inlineCode",{parentName:"p"},"Data Query")," gets resolved or evaluated. Which effectively means those API calls will happen only when a user visits that screen."),(0,n.kt)("h3",{id:"use-paging-in-large-datasets"},"Use paging in large datasets"),(0,n.kt)("p",null,"While working with large sets of data, its always advisable to use paging wherever possible while binding to table grid control etc. DronaHQ supports server-side paging in tablegrid and all oher similar controls. While showing aggregate information like analytics, its advisable to run these aggregations on the API or Database side before fetching the data. "),(0,n.kt)("h3",{id:"use-control-caching"},"Use control caching"),(0,n.kt)("p",null,"Slower data loading times are a major performance barrier when working with multiple datasets. You can find the Caching property for all the controls. It helps ensure that large datasets are fetched from the cache before making the actual connector call and also if the user is offline. "),(0,n.kt)("h3",{id:"restrict-the-number-of-queries-on-page-load"},"Restrict the number of queries on page load"),(0,n.kt)("p",null,"It is always advisable to restrict the number of queries on home page load and only work with data thats required for the home-screen. "),(0,n.kt)("h3",{id:"break-the-app-into-multiple-apps"},"Break the app into multiple apps"),(0,n.kt)("p",null,"Even after breaking down into multiple screen, the app is an extremely large app (running into 20-30+ screens) you should break the app into multiple apps. DronaHQ supports navigating between apps seamlessly and this sort of an architecture will only reduce the app load time as the app size becomes smaller."),(0,n.kt)("h3",{id:"check-query-performance"},"Check query performance"),(0,n.kt)("p",null,"In the debug tools, check for connector logs and see if you have long running or slow queries and if they can be optimized at your end. Dependency chains on these queries can slow down the app considerably. "),(0,n.kt)("h3",{id:"deploy-dronahq-on-premise"},"Deploy DronaHQ on-premise"),(0,n.kt)("p",null,"Deploying DronaHQ on-premise closer to your data sources can reduce the latency as well. Incase you are using SSH tunneling to your data sources you will see a considerable improvement in the query time."))}h.isMDXComponent=!0}}]);